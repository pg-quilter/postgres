--
-- Regular expression tests
--
-- Don't want to have to double backslashes in regexes
set standard_conforming_strings = on;
-- Test simple quantified backrefs
select 'bbbbb' ~ '^([bc])\1*$' as t;
 t 
---
 t
(1 row)

select 'ccc' ~ '^([bc])\1*$' as t;
 t 
---
 t
(1 row)

select 'xxx' ~ '^([bc])\1*$' as f;
 f 
---
 f
(1 row)

select 'bbc' ~ '^([bc])\1*$' as f;
 f 
---
 f
(1 row)

select 'b' ~ '^([bc])\1*$' as t;
 t 
---
 t
(1 row)

-- Test quantified backref within a larger expression
select 'abc abc abc' ~ '^(\w+)( \1)+$' as t;
 t 
---
 t
(1 row)

select 'abc abd abc' ~ '^(\w+)( \1)+$' as f;
 f 
---
 f
(1 row)

select 'abc abc abd' ~ '^(\w+)( \1)+$' as f;
 f 
---
 f
(1 row)

select 'abc abc abc' ~ '^(.+)( \1)+$' as t;
 t 
---
 t
(1 row)

select 'abc abd abc' ~ '^(.+)( \1)+$' as f;
 f 
---
 f
(1 row)

select 'abc abc abd' ~ '^(.+)( \1)+$' as f;
 f 
---
 f
(1 row)

-- Test some cases that crashed in 9.2beta1 due to pmatch[] array overrun
select substring('asd TO foo' from ' TO (([a-z0-9._]+|"([^"]+|"")+")+)');
 substring 
-----------
 foo
(1 row)

select substring('a' from '((a))+');
 substring 
-----------
 a
(1 row)

select substring('a' from '((a)+)');
 substring 
-----------
 a
(1 row)

-- Test conversion of regex patterns to indexable conditions
explain (costs off) select * from pg_proc where proname ~ 'abc';
            QUERY PLAN             
-----------------------------------
 Seq Scan on pg_proc
   Filter: (proname ~ 'abc'::text)
(2 rows)

explain (costs off) select * from pg_proc where proname ~ '^abc';
                              QUERY PLAN                              
----------------------------------------------------------------------
 Index Scan using pg_proc_proname_args_nsp_index on pg_proc
   Index Cond: ((proname >= 'abc'::name) AND (proname < 'abd'::name))
   Filter: (proname ~ '^abc'::text)
(3 rows)

explain (costs off) select * from pg_proc where proname ~ '^abc$';
                         QUERY PLAN                         
------------------------------------------------------------
 Index Scan using pg_proc_proname_args_nsp_index on pg_proc
   Index Cond: (proname = 'abc'::name)
   Filter: (proname ~ '^abc$'::text)
(3 rows)

explain (costs off) select * from pg_proc where proname ~ '^abcd*e';
                              QUERY PLAN                              
----------------------------------------------------------------------
 Index Scan using pg_proc_proname_args_nsp_index on pg_proc
   Index Cond: ((proname >= 'abc'::name) AND (proname < 'abd'::name))
   Filter: (proname ~ '^abcd*e'::text)
(3 rows)

explain (costs off) select * from pg_proc where proname ~ '^abc+d';
                              QUERY PLAN                              
----------------------------------------------------------------------
 Index Scan using pg_proc_proname_args_nsp_index on pg_proc
   Index Cond: ((proname >= 'abc'::name) AND (proname < 'abd'::name))
   Filter: (proname ~ '^abc+d'::text)
(3 rows)

explain (costs off) select * from pg_proc where proname ~ '^(abc)(def)';
                                 QUERY PLAN                                 
----------------------------------------------------------------------------
 Index Scan using pg_proc_proname_args_nsp_index on pg_proc
   Index Cond: ((proname >= 'abcdef'::name) AND (proname < 'abcdeg'::name))
   Filter: (proname ~ '^(abc)(def)'::text)
(3 rows)

explain (costs off) select * from pg_proc where proname ~ '^(abc)$';
                         QUERY PLAN                         
------------------------------------------------------------
 Index Scan using pg_proc_proname_args_nsp_index on pg_proc
   Index Cond: (proname = 'abc'::name)
   Filter: (proname ~ '^(abc)$'::text)
(3 rows)

explain (costs off) select * from pg_proc where proname ~ '^(abc)?d';
               QUERY PLAN               
----------------------------------------
 Seq Scan on pg_proc
   Filter: (proname ~ '^(abc)?d'::text)
(2 rows)

-- Test for infinite loop in pullback() (CVE-2007-4772)
select 'a' ~ '($|^)*';
 ?column? 
----------
 t
(1 row)

-- Test for infinite loop in fixempties() (Tcl bugs 3604074, 3606683)
select 'a' ~ '((((((a)*)*)*)*)*)*';
 ?column? 
----------
 t
(1 row)

select 'a' ~ '((((((a+|)+|)+|)+|)+|)+|)';
 ?column? 
----------
 t
(1 row)

-- Test backrefs with longer match
select REGEXP_SPLIT_TO_TABLE('ProgrammersInLinux','(\w).*\1','i');
 regexp_split_to_table 
-----------------------
 P
 s
 nux
(3 rows)

-- Test backrefs with shorter match
select REGEXP_SPLIT_TO_TABLE('ProgrammersInLinux','(\w).*?\1','i');
 regexp_split_to_table 
-----------------------
 P
 a
 ers
 nux
(4 rows)

-- Test backrefs with shorter match in REGEXP_* functions
SELECT REGEXP_SPLIT_TO_TABLE('Programmer','(\w).*?\1');
 regexp_split_to_table 
-----------------------
 P
 a
 er
(3 rows)

SELECT REGEXP_SPLIT_TO_ARRAY('Programmer','(\w).*?\1');
 regexp_split_to_array 
-----------------------
 {P,a,er}
(1 row)

SELECT REGEXP_REPLACE('Programmer', '(\w).*?\1', 'XX');
 regexp_replace 
----------------
 PXXammer
(1 row)

SELECT REGEXP_REPLACE('Programmer', '(\w).*?\1', 'XX', 'g');
 regexp_replace 
----------------
 PXXaXXer
(1 row)

SELECT REGEXP_MATCHES('Programmer', '(\w).*?\1');
 regexp_matches 
----------------
 {r}
(1 row)

